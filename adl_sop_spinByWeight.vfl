// Spins items using an existing weight. Can be applied to either packed primitives or most standard instance attributes.
// adl_sop_spinByWeight.vfl, by Andrew Louda
// Modified: 2025-10-05 - Added lop-compatible behavior and switched to a precompiler-based output method selection
// Copyright 2024 Andrew Louda. This file is licensed under the Apache 2.0 license.
// SPDX-License-Identifier: Apache-2.0

/* 
    The core functionality of this snippet is very simple, but it has been generalized so that it can operate on many different types of attributes.
    Spin weight is expected to be a vector ranging from -1 to 1 (though it can be whatever you want), 
    with max_rotate dictating the maximum rotation in degrees.
*/

#define OUTPUT_ORIENT(ORIENT_ATTRIB) (prerotate ? qmultiply(ORIENT_ATTRIB, qspin) : qmultiply(qspin, ORIENT_ATTRIB))
#define APPLY_TO_XFORM(XFORM_ATTRIB) (prerotate ? prerotate(XFORM_ATTRIB, rotamt, rOrd) : rotate(XFORM_ATTRIB, rotamt, rOrd))
string output_type = chs('output_type'); // [[menu_pairs={'orient':'Orient','rot':'Rot','transform3':'Transform (3x3)','transform4':'Transform (4x4)','packed':'Packed Prims','usd_primitives':'USD Primitives','usd_pointinstancer':'USD Point Instancer'} ]]
string class = chs('class'); // [[is_hidden]]
#if `strcmp( chs("output_type"), "usd_primitives") == 0`
    #define VTXNUM 0
    #define PRIMPATH @primpath
#else
    #define VTXNUM @vtxnum
    #define PRIMPATH ''
#endif

// Weight config & init
int weight_method = chi('weight_method'); // [[menu_items=('rand','weight','none'), menu_labels=('Random Per Element','Weight Attribute','None (Uniform)') ]]
vector spin_weight = 1;

// Random weight
#if `ch('weight_method') == 0`
    // folder[[name=rand_parms, folder_type='Collapsible', label='Configure Random', hide_when="{ weight_method != 0 output_type != usd_primitives}"]]
    string seed_attrib = chs('seed_attribute'); // [[folder=rand_parms, preset=attribSelectInt, help='Uses elemnum if blank', hide_when="{ output_type == usd_primitives }{ output_type == usd_pointinstancer }"]]
    int seed_primary = 0;
    #if `strcmp( chs("output_type"), "usd_primitives") == 0`
        seed_primary = random_ihash(random_shash(PRIMPATH));
    #else
        if( seed_attrib != '' ){
            seed_primary = getattrib(0, chs('class'), seed_attrib, i@elemnum, 0);
        }
        else{
            seed_primary = i@elemnum;
        }
    #endif
    float seed_secondary = chf("secondary_seed"); // [[folder=rand_parms,max=123]]
    spin_weight = vector(rand(set( seed_primary, seed_secondary)))*2-1;
#endif

// Weight from attribute
#if `ch('weight_method') == 1`
    // folder[[name=weight_parms, folder_type='Collapsible', label='Configure Weight', hide_when="{ weight_method != 1 }{ output_type == usd_primitives }"]]
    spin_weight = getattrib(0, class, chs('weight_attribute'), i@elemnum, 0); // [[folder=weight_parms, preset=attribSelectFloat, default='spinweight']]
#endif


// Rotation config
int rOrd = chi('rOrd'); // [[label='Rotation Order', menu_pairs={'xyz':'Rx Ry Rz','xzy':'Rx Rz Ry','yxz':'Ry Rx Rz','yzx':'Ry Rz Rx','zxy':'Rz Rx Ry','zyx':'Rz Ry Rx'}]]
vector rotamt = chv("max_rotate") * spin_weight; // [[default=0]]
chi('use_rotation_snapping'); // [[is_toggle, join_with_next, is_label_hidden]]

// Rotation snapping
#if `ch('use_rotation_snapping')`
    vector rotstep = chv('rotation_step'); // [[disable_when="{ use_rotation_snapping != 1 }"]]
    rotamt.x = rotstep.x != 0 ? rint(rotamt.x/rotstep.x)*rotstep.x : rotamt.x;
    rotamt.y = rotstep.y != 0 ? rint(rotamt.y/rotstep.y)*rotstep.y : rotamt.y;
    rotamt.z = rotstep.z != 0 ? rint(rotamt.z/rotstep.z)*rotstep.z : rotamt.z;
#endif

// Common rotation attributes
rotamt = radians(rotamt);
vector4 qspin = eulertoquaternion(rotamt,rOrd);
int prerotate = chi('prerotate'); // [[is_toggle, hide_when='{ output_type == usd_primitives }']]


// --------------------------------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------
// Rotation application methods


// orient
#if `strcmp( chs("output_type"), "orient") == 0`
    vector4 baseorient;
    if( hasattrib(0,class,'orient') ){
        baseorient = attrib(0,class,'orient',@elemnum); 
    }
    else{
        vector N = hasattrib(0,class,'N') ? normalize(attrib(0,class,'N',@elemnum)) : {0,1,0};
        vector up = hasattrib(0,class,'up') ? normalize(attrib(0,class,'up',@elemnum)) : {0,0,-1};
        baseorient = quaternion( chi('swap_n_up') ? maketransform( up, N) : maketransform( N, up) );  // [[is_toggle ,hide_when='{ output_type != orient }', help='If using N-up for base orient, swap which vector is used for which.' ]]
    }
    vector4 neworient = OUTPUT_ORIENT(baseorient);
    setattrib( 0, class, 'orient', @elemnum, VTXNUM, neworient, 'set');
#endif


// rot
#if `strcmp( chs("output_type"), "rot") == 0`
    vector4 newrot;
    if( hasattrib(0,class,'rot') ){
        vector4 baserot = attrib(0,class,'rot',@elemnum);
        newrot = OUTPUT_ORIENT(baserot);
    }
    else{
        newrot = qspin;
    }
    setattrib( 0, class, 'rot', @elemnum, VTXNUM, newrot, 'set');
#endif


// 3x3 Transform
#if `strcmp( chs("output_type"), "transform3") == 0`
    matrix3 xform;
    if( hasattrib(0,class,'transform') ){
        xform = getattrib(0,class,'transform',@elemnum,0);
        APPLY_TO_XFORM(xform);
    }
    else{
        xform = qconvert(qspin);
    }
    setattrib( 0, class, 'transform', @elemnum, VTXNUM, xform, 'set');
#endif


// 4x4 Transform
#if `strcmp( chs("output_type"), "transform4") == 0`
    matrix xform;
    if( hasattrib(0,class,'transform') ){
        xform = getattrib(0,class,'transform',@elemnum,0);
        APPLY_TO_XFORM(xform);
    }
    else{
        xform = qconvert(qspin);
    }
    setattrib( 0, class, 'transform', @elemnum, VTXNUM, xform, 'set');
#endif


// Packed Primitives
#if `strcmp( chs("output_type"), "packed") == 0`
    matrix3 xform = primintrinsic(0,'transform',@elemnum);
    APPLY_TO_XFORM(xform);;
    setprimintrinsic(0,'transform',@elemnum,xform,'set');
#endif


// USD Primitives
#if `strcmp( chs("output_type"), "usd_primitives") == 0`
    matrix xform = maketransform(rOrd,degrees(rotamt));
    usd_addtransform( 0, PRIMPATH, 'spinByWeight', xform);
#endif


// USD Point Instancer
#if `strcmp( chs("output_type"), "usd_pointinstancer") == 0`
    p@orientations = OUTPUT_ORIENT(p@orientations);
#endif
